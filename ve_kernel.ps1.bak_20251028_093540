param(
  [ValidateSet("exec","status","audit")]
  [string]$Command = "status",
  [string]$Ledger  = ".\ve_ledger.jsonl",
  [string]$Policy  = ".\policy.ve.psl",
  [string]$ExtLang,
  [string]$Target,
  [string]$Exec,
  [double]$Rho = 0.0,
  [double]$Gamma = 0.0,
  [double]$Delta = 0.0,
  [double]$PsiScore = -1.0,
  [int]$MaxRuntimeSecs = 60,
  [switch]$StrictPsi,
  [switch]$Quiet
)

$ErrorActionPreference = "Stop"

function Append-NoBomLine([string]$Path,[string]$Text){
  [System.IO.File]::AppendAllText($Path,$Text + [Environment]::NewLine,[System.Text.UTF8Encoding]::new($false))
}
function Get-Sha256([string]$text){
  $b = [Text.Encoding]::UTF8.GetBytes($text)
  $s = [Security.Cryptography.SHA256]::Create()
  ($s.ComputeHash($b) | ForEach-Object { $_.ToString('x2') }) -join ''
}
function Get-FileSha256([string]$path){
  if(-not (Test-Path $path)){ return "" }
  (Get-FileHash -Algorithm SHA256 $path).Hash.ToLower()
}

function Read-Policy([string]$path){
  $obj = [ordered]@{
    floor = 1.38
    allow = @('powershell','python','bash')
    max_runtime_secs = 60
    hash = ""
  }
  if(Test-Path $path){
    $txt = Get-Content $path -Raw
    $m = [regex]::Match($txt,'(?ms)^\[psi\].*?floor\s*=\s*([0-9\.]+)')
    if($m.Success){ $obj.floor = [double]$m.Groups[1].Value }
    $m = [regex]::Match($txt,'(?ms)^\[ext\].*?allow\s*=\s*\[([^\]]*)\]')
    if($m.Success){
      $obj.allow = ($m.Groups[1].Value -split ',') | ForEach-Object { $_.Trim().Trim('"').Trim("'") } | Where-Object { $_ -ne '' }
    }
    $m = [regex]::Match($txt,'(?ms)^\[ext\].*?max_runtime_secs\s*=\s*([0-9]+)')
    if($m.Success){ $obj.max_runtime_secs = [int]$m.Groups[1].Value }
    $obj.hash = (Get-Sha256($txt))
  }
  return $obj
}

function Get-LastSeqHash([string]$ledger){
  if(-not (Test-Path $ledger)){ return @{ seq=0; hash="" } }
  $lines = Get-Content $ledger -ErrorAction SilentlyContinue
  if(-not $lines -or $lines.Count -eq 0){ return @{ seq=0; hash="" } }

  # Walk backwards to find the last valid JSON line
  for ($i = $lines.Count - 1; $i -ge 0; $i--) {
    $l = "" + $lines[$i]
    $t = $l.Trim()
    if ($t -and $t.StartsWith("{") -and $t.EndsWith("}")) {
      try {
        $obj = $t | ConvertFrom-Json
        return @{ seq = [int]$obj.seq; hash = [string]$obj.hash_self }
      } catch {
        continue
      }
    }
  }
  return @{ seq=0; hash="" }
}}
  $lines = Get-Content $ledger -ErrorAction SilentlyContinue
  if(-not $lines -or $lines.Count -eq 0){ return @{ seq=0; hash="" } }

  # Walk backwards to find the last valid JSON line
  for ($i = $lines.Count - 1; $i -ge 0; $i--) {
    $l = "" + $lines[$i]
    $t = $l.Trim()
    if ($t -and $t.StartsWith("{") -and $t.EndsWith("}")) {
      try {
        $obj = $t | ConvertFrom-Json
        return @{ seq = [int]$obj.seq; hash = [string]$obj.hash_self }
      } catch {
        # not valid JSON; keep scanning
        continue
      }
    }
  }
  # Nothing valid found
  return @{ seq=0; hash="" }
} }
  $lines = Get-Content $ledger
  if(-not $lines -or $lines.Count -eq 0){ return @{ seq=0; hash="" } }
  $last = $lines[-1] | ConvertFrom-Json
  return @{ seq = [int]$last.seq; hash = [string]$last.hash_self }
}

function With-Lock([ScriptBlock]$Body){
  $lockPath = Join-Path (Split-Path -Parent $Ledger) 've_ledger.lock'
  $fs = $null
  try{
    $fs = [System.IO.File]::Open($lockPath,[System.IO.FileMode]::OpenOrCreate,[System.IO.FileAccess]::ReadWrite,[System.IO.FileShare]::None)
    & $Body
  } finally {
    if($fs){ $fs.Close(); $fs.Dispose() }
  }
}

function Make-GenesisIfNeeded{
  if(Test-Path $Ledger){
    try {
      $len = (Get-Item $Ledger).Length
      if ($len -gt 0) { return }
    } catch { }
  }
  $ts = [DateTime]::UtcNow.ToString('yyyy-MM-ddTHH:mm:ss.fffZ')
  $gen = [ordered]@{
    seq=1
    timestamp_utc=$ts
    hash_prev=("0"*64)
    hash_self=""
    hash_policy=""
    action="GENESIS"
    target=""
    status="OK"
    exit_code=0
    psi_score=0.0
    ext_lang=""
    ext_hash=""
  }
  $jsonCompact = ($gen | ConvertTo-Json -Compress)
  $gen.hash_self = Get-Sha256($jsonCompact)
  $jsonCompact = ($gen | ConvertTo-Json -Compress)
  Append-NoBomLine $Ledger $jsonCompact
}

switch($Command){
  'status' {
    if(-not (Test-Path $Ledger)){ if(-not $Quiet){ Write-Host "No ledger yet." }; exit 0 }
    $lines = Get-Content $Ledger
    $tail = $lines | Select-Object -Last 5
    if(-not $Quiet){ $tail }
    exit 0
  }

  'audit' {
    $py = $null
    $pcmd = Get-Command python -ErrorAction SilentlyContinue
    if($pcmd){ $py = $pcmd.Source } else {
      $pcmd = Get-Command py -ErrorAction SilentlyContinue
      if($pcmd){ $py = $pcmd.Source }
    }
    if(-not $py){ Write-Error "Python not found (FAIL_ENV)"; exit 2 }

    $policy = Read-Policy $Policy
    $psiMin = $policy.floor
    if (-not $psiMin) { $psiMin = 1.38 }
    $argsList = @(".\ve_schema_check.py","--ledger",$Ledger,"--psi-min",[string]$psiMin)
    if($StrictPsi){ $argsList += "--strict-psi" }

    & $py @argsList 2>&1 | Out-Host
    exit $LASTEXITCODE
  }

  'exec' {
    $policy = Read-Policy $Policy
    $psiMin = $policy.floor
    if (-not $psiMin) { $psiMin = 1.38 }

    if([string]::IsNullOrEmpty($ExtLang)){
      if($Exec -match '^\s*python\b'){ $ExtLang='python' }
      elseif($Exec -match '^\s*powershell\b'){ $ExtLang='powershell' }
      elseif($Exec -match '^\s*bash\b'){ $ExtLang='bash' }
      else { $ExtLang='powershell' }
    }

    $allowed = @()
    if ($policy -and $policy.allow) {
      $allowed = @($policy.allow | Where-Object { $_ } | ForEach-Object { $_.ToString().ToLower() })
    }
    if (-not $allowed) { $allowed = @('powershell','python','bash') }
    if (-not ($allowed -contains $ExtLang.ToLower())) {
      Write-Error ("FAIL_ENV: ext_lang '{0}' not allowed by policy (allowed: {1})" -f $ExtLang, ($allowed -join ', '))
      exit 2
    }

    if($PsiScore -lt 0){ $PsiScore = [Math]::Round(($Rho + $Gamma),2) }
    if([string]::IsNullOrWhiteSpace($Exec)){ Write-Error "FAIL_ENV: Exec command is empty"; exit 2 }

    With-Lock {
      Make-GenesisIfNeeded
      $latest   = Get-LastSeqHash $Ledger
      $seq      = $latest.seq + 1
      $prevHash = $latest.hash
      $ts       = [DateTime]::UtcNow.ToString('yyyy-MM-ddTHH:mm:ss.fffZ')
      $extHash  = ""
      if($Target -and (Test-Path $Target)){ $extHash = Get-FileSha256 $Target }

      # compute wait timeout (no ternary)
      $waitMs = 60000
      if ($policy -and $policy.max_runtime_secs) {
        try {
          $mr = [int]$policy.max_runtime_secs
          if ($mr -gt 0) { $waitMs = $mr * 1000 }
        } catch { }
      }
      if ($MaxRuntimeSecs -gt 0) {
        try { $waitMs = [int]$MaxRuntimeSecs * 1000 } catch { }
      }

      # run external
      $ps = New-Object System.Diagnostics.Process
      $psi = New-Object System.Diagnostics.ProcessStartInfo
      $psi.FileName = "powershell.exe"
      $psi.Arguments = "-NoProfile -NonInteractive -Command `"$Exec`""
      $psi.RedirectStandardOutput = $true
      $psi.RedirectStandardError  = $true
      $psi.UseShellExecute = $false
      $psi.CreateNoWindow = $true
      $ps.StartInfo = $psi
      $null = $ps.Start()
      if(-not $ps.WaitForExit($waitMs)){
        try { $ps.Kill() } catch {}
        $exitCode = 124
      } else {
        $exitCode = $ps.ExitCode
      }
      $stdout = $ps.StandardOutput.ReadToEnd()
      $stderr = $ps.StandardError.ReadToEnd()

      $status = "OK"
      if($exitCode -ne 0){ $status = "FAIL_EXIT" }
      elseif($StrictPsi -and ($PsiScore -lt $psiMin)){ $status = "FAIL_PSI" }

      $targetOut = ""
      if(-not [string]::IsNullOrWhiteSpace($Target)){ $targetOut = $Target }

      $rec = [ordered]@{
        seq = $seq
        timestamp_utc = $ts
        hash_prev = $prevHash
        hash_self = ""
        hash_policy = $policy.hash
        action = "exec"
        target = $targetOut
        status = $status
        exit_code = $exitCode
        psi_score = [double]$PsiScore
        ext_lang = $ExtLang
        ext_hash = $extHash
      }
      $json = ($rec | ConvertTo-Json -Compress)
      $rec.hash_self = Get-Sha256($json)
      $json = ($rec | ConvertTo-Json -Compress)
      Append-NoBomLine $Ledger $json

      if(-not $Quiet){
        "`n--- VE EXEC REPORT ---"
        "seq=$seq, exit_code=$exitCode, status=$status"
        "stdout:"
        $stdout
        "stderr:"
        $stderr
      }

      # immediate audit (best-effort)
      $py = $null
      $pcmd = Get-Command python -ErrorAction SilentlyContinue
      if($pcmd){ $py = $pcmd.Source } else {
        $pcmd = Get-Command py -ErrorAction SilentlyContinue
        if($pcmd){ $py = $pcmd.Source }
      }
      if($py){
        $argsList = @(".\ve_schema_check.py","--ledger",$Ledger,"--psi-min",[string]$psiMin)
        if($StrictPsi){ $argsList += "--strict-psi" }
        & $py @argsList 2>&1 | Out-Host
        exit $LASTEXITCODE
      } else {
        Write-Warning "Python not found; skipping immediate audit."
        exit 0
      }
    }
  }
}
